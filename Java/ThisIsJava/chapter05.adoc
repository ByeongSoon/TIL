= 5장. 참조 타입

:icons: font
:Author: Byeongsoon Jang
:Email: byeongsoon94@gmail.com
:Date: 2020.08.20
:Revision: 1.0
:imagesdir: ./image


책 '이것이 자바다 - 신용권'를 학습하면서 기억해두면 좋은점을 기록한다.

여러번 보면서 놓쳤던 부분들을 체크하며, 기본에 충실한다.

Byeongsoon Jang<byeongsoon94@gmail.com>

---

==== 데이터 타입 분류

프로그램이 하는 일은 결국엔 데이터를 얼마나 효율적이고 정확하게 처리하는 것이냐가 관건이다.

자바의 데이터 타입은 크게 두가지로 나뉜다.

* 기본 타입

** 정수 타입
*** byte
*** char
*** short
*** int
*** long
** 실수 타입

*** float
*** double
** 논리 타입

*** boolean

* 참조 타입

** 배열 타입
** 열거 타입
** 클래스
** 인터페이스

기본 타입과 참조 타입으로 선언된 변수의 가장 큰 차이는 저장되는 값이 무언인가 이다.

기본 타입으로 선언된 변수는 실제 값을 저장하지만, 참조 타입으로 선언된 변수는 메모리의 주소값을 갖는다.

해당 메모리 주소를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다.

image::chap05_01.png[자바 메모리 영역, 600]

변수는 Stack 영역에 생성되고 객체는 Heap 영역에 생성된다.

==== 메모리 사용 영역

JVM Stack 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.

[TIP]
====
자바에서는 배열을 객체로 취급한다.
====

==== 참조 변수의 ==,!= 연산

참조 변수의 값은 메모리의 주소 값을 가지고 있으므로 비교 연산에서도 주소 값을 비교한다.

동일한 객체를 참조하고 있으면 변수가 다르더라도 결국 같은 주소 값을 가지고 있을 것이다.

참조 타입의 비교 연산을 주로 사용할때는 if문의 조건식 부분일텐데 같은 타입의 참조 변수라고 ==을 사용하면 true가 나올 것이라는 생각은 버려야한다.

==== null과 NullPointerException

참조 변수는 Heap 영역의 객체를 참조하지 않을땐 null 값을 가질 수 있다.

자바는 프로그램 실행 도중에 발생하는 오류를 예외(Exception)라고 부른다.

예외가 발생되는 경우는 많다. 잘못된 코딩이나 잘못된 입력 등에서 발생한다.

이중에서 가장 많이 발생하는 예외 중 하나로 NullPointerException이 있다.

참조 타입 변수가 null을 가지고 있을 경우 참조 타입 변수는 사용할 수 없다.

참조 타입 변수를 사용한다는건 그 변수가 가지고 있는 주소의 객체를 사용한다는 것인데 객체가 없으므로 사용한다면 예외가 발생한다.

[source, java]
----
String name = null;
System.out.println("이름의 길이 : " + name.length()); // NullPointerException 발생
----

NullPointerException이 발생하면, 발생된 곳에서 객체를 참조하지 않은 상태로 참조 타입 변수를 사용하고 있음을 알아야 한다.

==== String 타입

자바는 문자열을 String 타입의 변수에 저장한다.

하지만 문자열을 String 타입에 저장한다는 말은 틀린 표현이다.

문자열은 String 객체로 생성되고 변수는 이 객체를 참조하기 때문에 정확히 말하자면 String 타입의 참조된 객체에 저장하는게 맞는 표현이다.

[TIP]
====
자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.

다음과 같이 name1과 name2 변수가 동일한 리터럴인 경우에 name1, name2는 동일한 String 객체를 참조한다.

[source,java]
----
String name1 = "장봉";
String name2 = "장봉";
----
====

일반적으로 변수에 문자열을 저장할 경우에는 리터럴을 사용하지만 new 연산자를 이용해서 직접 String 객체를 생성할 수 있다.

new 연산자는 새로운 Heap 영역에 객체를 생성하므로 객체 생성 연산자라고도 불린다.

[source, java]
----
String name1 = new String("장봉");
String name2 = new String("장봉");
----

위의 경우는 name1, name2 각각 다른 객체를 참조한다.

문자열 리터럴로 생성하느냐 아니면 new 연산자로 생성하느냐에 따라 비교 연산자의 결과가 달라진다.

[source, java]
----

----

[source, java]
----

----
