= 8장. 인터페이스

:icons: font
:Author: Byeongsoon Jang
:Email: byeongsoon94@gmail.com
:Date: 2020.09.03
:Revision: 1.0
:imagesdir: ./image


책 '이것이 자바다 - 신용권'를 학습하면서 기억해두면 좋은점을 기록한다.

여러번 보면서 놓쳤던 부분들을 체크하며, 기본에 충실한다.

{Author}<{Email}>

---

==== 인터페이스의 역할

자바에서 인터페이스는 객체의 사용 방법을 정의한 타입이라고 말할 수 있다.

인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.

[TIP]
====
자바 8의 람다식은 함수적 인터페이스의 구현 객체를 생성한다.
====

==== 인터페이스 선언

인터페이스 선언은 interface 키우드를 사용한다.

[source, java]
----
[ public ] interface 인터페이스명 {
  // 상수
  타입 상수명 = 값;

  // 추상 메소드
  타입 메소드명(매개변수,...);

  //디폴트 메소드
  default 타입 메소드명(매개변수, ...) {
    ...
  }

  // 정적 메소드
  static 타입 메소드명(매개변수, ...) {
    ...
  }
}
----

인터페이스는 상수와 메소드만을 멤버로 가진다.

자바 8부터 추가된것이 디폴트 메소드와 정적 메소드이다.

* 상수 필드(Constant Field)
** 인터페이스는 데이털르 저장할 수 있는 필드를 선언할 수 없다.
** 상수를 선언할 때에는 반드시 초기값을 대입해야 한다.

* 추상 메소드(Abstract Method)
** 호출할 때 언떤 매개값이 필요하고, 리턴 낭비이 무엇인지만 알려준다.
** 실행부는 구현 클래스에 작성한다.

* 디폴트 메소드(Default Method)
** 인터페이스에 선언되지만 구현 객체가 가지고 있는 인스턴스 메소드이다.

* 정적 메소드(Static Method)
** 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.

상수는 선언할 때 public static final로 선언하는데 인터페이스에 선언된 필드는 모두 이 상수의 특성을 갖기 때문에 public, static, final을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.

[TIP]
====
상수명은 대문자로 작성하되, 서로 다른 단어로 구성되어 있을 경우에는 언더바로 연결하는 것이 관례이다.

[source,java]
----
public interface Control {
  public int MAX_VOLUME = 10;
  public int MIN_VOLUME = 0;
}
----
====

인터페이스의 멤버 중 대표적인 추상 메소드는 실행 블록이 없이 리턴 타입, 메소드명, 매개 변수만 기술한다.

인터페이스에 선언된 추상 메소드는 모두 public abstract 특성을 갖기 때문에 생략해도 자동적으로 컴파일 과정에서 붙게 된다.

[source,java]
----
public void setVolume(int volume);
----

디폴트 메소드는 default 키워드가 맨앞에 위치하고, 작성 방법은 클래스의 메소드와 같다. public 특성을 갖기 때문에 생략해도 컴파일 과정에서 붙게 된다.

정적 메소드는 인터페이스로 바로 호출이 가능하다.

==== 인터페이스 구현

인터페이스에 정의한 추상 메소드의 실행 가능한 실체 메소드를 가진 객체를 구현(implement) 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.

.interface 구현 클래스
[source, java]
----
public class ClassName implements InterfaceName {
  // 인터페이스에 선언된 추상 메소드의 실체 메소드
}
----

구현 클래스는 클래스 이름 뒤에 implements 키워드를 추가하고 인터페이스명을 명시해야 한다.

구현 클래스에서 추상 메소드의 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 접근제한자가 public이기 때문에 public보다 더 낮은 접근 제한으로 작성할 수 없다.

[IMPORTANT]
====
만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스에 작성하지 않으면 구현 클래스는 자동적으로 추상 클래스가 된다.

-> 구현 클래스에서 추상 메소드의 내용을 반드시 작성하거나 구현 클래스를 선언할 때 abstract 키워드를 추가해 추상 클래스로 선언한다.
====

===== 익명 구현 객체

익명이라고 함은 말 그대로 이름이 없는 구현 객체를 만드는 것이다.

이름이 없다는 것은 따로 구현 클래스를 만들지 않고 구현 객체를 생성자 중괄호를 이용해 구현한다.

작성 시 주의할 점은 익명 구현 객체는 하나의 실행문이므로 반드시 끝에 세미콜론(;)을 붙여줘야 한다.

.익명 구현 객체
[source, java]
----
인터페이스 변수명 = new 인터페이스() {
  // 인터페이스에 선언된 추상 메소드의 실체 구현부
};
----

new 연산자 뒤에 우리는 지금까지 클래스 이름을 붙여서 생성자를 호출했었는데 여기서는 인터페이스 이름을 사용한다.

여기서 중괄호에는 인터페이스에 선언된 모든 추상 메소드의 실체 메소드를 작성하여야 한다. 클래스를 선언하는 것이 아니기 때문에 추상 메소드를 다 이용하지 않으면 추상 클래스가 된다는 것에 어긋나기 때문이다.

===== 다중 인터페이스 구현 클래스

자바에서는 클래스를 다중 상속할 수 없다고 학습했다.

하지만 인터페이스는 다중 구현 클래스를 만들 수 있다.

[source, java]
----
public class ClassName implements InterfaceName1, InterfaceName2 {
  // InterfaceName1에 선언된 추상 메소드의 실체 메소드
  // InterfaceName2에 선언된 추상 메소드의 실체 메소드
}
----

==== 인터페이스 사용

인터페이스를 사용할 때는 인터페이스 변수를 선언하고 구현 객체를 대입해서 사용한다.

[source, java]
----
인터페이스 변수 = 구현객체;

or

인터페이스 변수;
변수 = 구현객체;
----

개발 코드에서 인터페이스는 클래스의 필드, 생성자 또는 메소드의 매개 변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있다.

===== 추상 메소드 사용

인터페이스에 선언된 추상 메소드를 구현 클래스에서 실체 메소드를 구현한다.

사용은 인터페이스 타입으로 선언된 변수에 구현 객체를 생성한 뒤 메소드를 호출하면 구현 클래스에서 작성한 메소드가 실행된다.

===== 디폴트 메소드 사용

디폴트 메소드는 인터페이스에서 선언되지만, 인터페이스에서 바로 사용할 수 없다.

추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다.

디폴트 메소드는 인터페이스의 모든 구현 객채가 가지고 있는 기본 메소드라고 생각하면 된다.

디폴트 메소드는 구현 클래스에서 Override 할 수 있다.

===== 정적 메소드 사용

정적 메소드는 인터페이스로 바로 호출이 가능하다.

구현 객체가 필요없이 바로 호출할 수 있다.

==== 타입 변환과 다형성

인터페이스를 사용해 다형성을 구현하는 것은 상속과 마찬가지로 타입 변환이다.

인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다.

메소드를 선언할 때 인터페이스 타입으로 매개 변수를 선언하면 메소드 호출 시 매개값으로 여러 가지 종류의 구현 객체를 줄 수 있기 때문에 메소드 실행 결과가 다양하게 나온다.

===== 자동 타입 변환(Promotion)

구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환이다.

인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었어도 인터페이스 타입으로 자동 타입 변환을 시킬 수 있다.

인터페이스 타입은 필드 선언 시 필드 타입, 배열, 매개 변수 등 다양한 방법으로 다형성을 구현한다.

===== 강제 타입 변환(Casting)

구현 객체가 인터페이스 타입으로 자동 변환 되면, 인터페이스에 선언된 메소드만 사용 가능하다.

예를 들어, 인터페이스에 3개의 메소드가 선언되어 있고, 구현 객체에 5개의 메소드가 선언되어 있다면 인터페이스로 호출 가능한 것은 3개 뿐이다.

이땐 강제 타입 변환을 사용해 원래 클래스 타입으로 강제 변환하여 사용하여야 한다.

[TIP]
====
인터페이스 타입으로 자동 변환된 매개값을 메소드 내에서 다시 구현 클래스 타입으로 강제 타입 변환을 해야 한다면 반드시 매개값이 어떤 객체인지 instanceof 연산자를 사용해서 타입을 확인하고 안전하게 강제 타입 변환을 해야한다.
====

==== 인터페이스 상속

인터페이스도 클래스와 마찬가지로 상속을 할 수 있는데, 클래스와 달리 다중 상속을 허용 한다.

.인터페이스 상속
[source, java]
----
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {
  ...
}
----

하위 인터페이스를 구현하는 구현 클래스는 하위 인터페이스뿐만 아니라 상위 인터페이스에 선언된 모든 추상 메소드에 대한 실체 메소드를 구현해야 한다.

==== 디폴트 메소드와 인터페이스 확장

디폴트 메소드는 구현 객체가 있어야 사용이 가능하다. 그런데 선언은 인터페이스에서 하고 사용은 구현 객체에서 하는 것이 뭔가 효율적이지 않아 보인다.

디폴트 메소드의 필요성은 다른 곳에서 나온다.

인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.

만약에 인터페이스를 구현한 구현 객체가 두개가 있다고 생각하자.

개발을 하는 도중에 B라는 구현 클래스에서 메소드를 추가해야하는 상황이 생겼는데, 이를 인터페이스에 추상 메소드로 선언한다면 구현 클래스 A에서도 이 메소드에 대한 실체 메소드를 작성해야 하는 단점이 있다.

이때 디폴트 메소드를 사용하면 미리 만들어둔 A 클래스는 그대로 써도 되고 B 클래스에서는 해당 디폴트 메소드를 그대로 사용하던지 아니면 오버라이딩해서 사용하면 된다.

----
여기서 내 생각을 잠시 적어본다면, 그렇다면 인터페이스에 디폴트 메소드를 하나정도 미리 선언해서 와일드카드로 사용하면 나중에 더 편리하지 않을까?

또 만약에 구현 클래스 B에서만 필요하다고 하더라도 인터페이스에 디폴트 메소드로 선언을 해두면 강제 타입 변환 같은 불편한 작업은 안해도 되지 않을까?
----

[TIP]
====
부모 인터페이스에 선언된 디폴트 메소드를 자식 인터페이스에서 @Override를 이용해서 추상 메소드로 재선언 할 수 있다.
====
