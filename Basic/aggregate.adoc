= 3장 애그리거트

:icons: font
:Author: Byeongsoon Jang
:Email: byeongsoon@wisoft.io
:Date: 2018.07.25
:Revision: 1.0
:imagesdir: ./image

DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기 - 최범균

==== 이 장에서 다룰 내용
* 애그리거트
* 애그리거트 루트와 역할
* 애그리거트와 리포지터리
* ID를 이용한 애그리거트 참조

Byeongsoon Jang<byeongsoon@wisoft.io>

|===
|===

==== 용어 정리

[cols="1,3", option = "header"]
|===
^|요소 ^| 설명
|엔티티(ENTITY) | 고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다. 주문(Order), 회원(Member), 상품(Product)과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 제공한다.

|밸류(VALUE) | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소(Address)나 구매 금액을 위한 금액(Money)과 같은 타입이 밸류 타입이다. 엔티티 속성으로 사용될 뿐만 아니라 다른 밸류 타입의 속성으로도 사용될 수 있다.

|애그리거트(AGGREGATE) | 애그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어, 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다.

|리포지터리(REPOSITORY) | 도메인 모델의 영속성을 처리한다. 예를 들어, DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.

|도메인 서비스(DOMAIN SERVICE) | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다.
|===

==== 애그리거트

온라인 쇼핑몰을 위한 시스템을 개발한다고하자.

[그림 3.1]과 같이 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 데 도움이 된다.

image::ch3_1.png[그림3.1, 700]

이 그림을 보면 주문은 회원, 결제, 상품과 관련이 있다는 것을 쉽게 파악할 수 있다.

상위 수준 모델을 개별 객체 단위로 다시 그려보면 [그림 3.2]와 같다.

image::ch3_2.png[그림3.2, 700]

그림 3.1과 같이 상위 모델에 대한 이해 없이 그림 3.2만 보고 상위 수준에서 개념을 파악하려면 더 오랜 시간이 걸린다.

====
백 개 이상의 테이블을 한 장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는 데 어려욺을 겪게 되는 것처럼,
도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
====

* 주요 도메인 개념 간의 관계를 파악하기 어렵다는 것은 곧 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다.

* 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 **애그리거트**이다.
** 애그리거트는 관련된 객체를 하나의 군으로 묶어준다.
** 수많은 객체를 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.

[그림 3.3]은 [그림 3.2]의 모델을 애그리거트로 묵어서 다시 표현한 것이다.

image::ch3_3.png[그림3.3, 700]

* 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다.

* 애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
** 주문 애그리거트를 만들려면 Order, OrderLine, Orderer와 같은 관련 객체를 함께 생성해야 한다.
** 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.

* [그림 3.3]에서 보는 것처럼 애그리거트는 경계를 갖는다.
** 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
** 애그리거트는 독립된 객체 군이며, 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

* 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.

* 흔히 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다.
주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느정도 타당해 보인다.
하지만 'A가 B를 갖는다'로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.
** 좋은 예가 상품과 리뷰이다.
*** 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰 내용을 보여줘야 한다는 요구사항이 있다면 Product 엔티티와 Review 엔티티가 한 애그리거트에 속한다고 생각할 수 있다.

image::ch3_4.png[그림3.4, 700]

Review의 변경이 Product에 영향을 주지 않고 반대로 Product의 변경이 Review에 영향을 주지 않기 때문에 이 둘은 한 애그리거트에 속한다기보다는 [그림 3.3]에 표시한 것처럼 서로 다른 애그리거트에 속한다.

==== 애그리거트 루트

* 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안된다.
도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져와야 한다.

* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티 이다.
** 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티로 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다.

image::ch3_5.png[그림3.5,700]

주문 애그리거트에서 루트 역할을 하는 엔티티는 Order이다.
OrderLine, ShippingInfo, Orderer 등 주문 애그리거트에 속한 모델은 Order에 직접 또는 간접적으로 속한다.

===== 도메인 규칙과 일관성

* 애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다.
** 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 가능을 구현한다.

* 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
** 예를 들어, 배송이 시작되기 전까지만 배송지 정보를 변경할 수 있다는 규칙이 있다면, 애그리거트 루트인 Order의 changeShippingInfo() 메서드는 이 규칙에 따라 배송 시작 여부를 확인하고 변경이 가능한 경우에만 배송지 정보를 변경해야 한다.

* 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다. 이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.

* 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
** 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
** 밸류 타입은 불변으로 구현한다.
*** 밸류 객체가 불벼ㅑㄴ이면 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다. 즉, 애그리거트 루트가 제공하는 메서드에 새로운 밸류 객체를 전달해서 값을 변경하는 방법밖에 없다.

===== 애그리거트 루트의 기능 구현

애그리거트 루트는 내부의 다른 객체를 조합해서 기능을 완성한다.

애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다.
기능 실행을 위임하기도 한다.

===== 트랜잭션 범위

트랜잭션 범위는 작을수록 좋다.

DB 테이블을 기준으로 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것은 성능에서 차이가 발생한다.

한 개 테이블을 수정할 때에는 트랜잭션 충돌을 막기 위해 잠그는 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.

잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하고 이는 전체적인 성능을 떨어뜨린다.

* 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
** 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.

* 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 뜻한다.

* 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만 다음의 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
** 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
** 기술 제약: 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
** UI 구현의 편리: 운영자의, 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경할 수 있을 것이다.

==== 애그리거트와 리포지터리

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.

* 새로운 애그리거트를 만들면 저장소에 애그리거트를 영속화하고 애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 하므로 리포지터리는 적어도 다음의 두 메서드를 제공해야 한다.
** save: 애그리거트 저장
** findById: ID로 애그리거트를 구함

[TIP]
====
영속성 : 영원히 계속되는 성질이나 능력.

영속화란,

비영속 상태의 객체를 저장소에 저장하여 영속 상태로 만드는 것.
====

이 두 메서드 외에 필요에 따라 다양한 조건으로 애그리거트를 검색하는 메서드나 애그리거트를 삭제하는 메서드를 추가할 수 있다.

* 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.

====
ORM 기술 중의 하나인 JPA/하이버네이트를 사용하면 데이터베이스 관계형 모델에 객체 도메인 모델을 맞춰야 하는 경우도 있다.

@Component: JPA에서 밸류 타입을 매핑할 때 사용하는 애노테이션.

@Entity: 엔티티를 매핑할 때 사용하는 애노테이션.
====

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.

* 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.
** 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException과 같은 문제가 발생하게 된다.

* 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.
** 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.

==== ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다.

애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과 같다.

* 애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다. 예를 들어, 주문 애그리거트에 속해있는 Orderer는 [그림 3.6]처럼 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 Member를 필드로 참조 할 수 있다.

image::ch3_6.png[그림3.6, 700]

* 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.

JPA를 사용하면 @ManyToOne, @OneToOne과 같은 애노테이션을 이용해서 연관된 객 체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해서 다른 애그리거트를 쉽게 참조할 수 있다.

====
ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있고, 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터를 객체 탐색을 통해 조회할 수 있다. 하지만, 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.

* 편한 탐색 오용
** 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
트랜잭션 범위에서 언급한 것처럼 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.

* 성능에 대한 고민
** JPA를 사용할 경우 참조한 객체를 지연(lazy) 로딩과 즉시(eager) 로딩의 두 가지 방식으로 로딩할 수 있다.
구 로딩 방식중 무엇을 사용할 지 여부는 애그리거트의 어떤 기능을 사용하느냐에 따라 달라진다.
단순히 연관된 객체의 데이터를 함께 화면에 보여주어야 한면 즉시 로딩이 조회 성능에 유리하지만, 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불필요한 객체를 함께 로딩할 필요가 없으므로 지연 로딩이 유리하다.

* 확장 어려움
** 초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다.
문제는 사용자가 몰리기 시작하면서 발생한다. 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.
이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다.

위의 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.

image::ch3_7.png[그림3.7,700]

ID를 이용한 참조는 DB테이블에서의 외래키를 사용해서 참조하는 것과 비슷하게 다른 애그리거트를 참조할 때 ID 참조를 사용한다는 것이다.
====

* ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.

* 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.
중요한 데이터인 주문 애그리거트는 RDBMS에 저장하고 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다.
또한, 각 도메인을 별도 프로세스로 서비스하도록 구현할 수도 있다.

[TIP]
====
RDBMS,

관계형 데이터베이스 관리 시스템으로 관계형 모델을 기반으로 하는 데이터베이스 관리 시스템이다.
현재 사용되는 대부분의 데이터베이스는 관계형 데이터베이스 모델을 기반으로 한다.

NoSQL 데이터베이스,

확장 가능한 성능 및 스키마 없는 데이터 모델에 최적화된 비관계형 데이터베이스이다.
또한, NoSQL 데이터베이스는 개발 용이성, 짧은 지연 시간 및 복원력으로 널리 인정받고 있다.
열 기반, 문서, 그래프, 인 메모리 키-값 스토어를 비롯한 다양한 데이터 모델을 사용한다.
====

image::ch3_8.png[그림3.8, 700]

==== 애그리거트 간 집합 연관

애그리거트 간 1:N과 M:N 연관에 대해 살펴본다.

이 두 연관은 컬렉션을 이용한 연관이다. 카테고리와 상품간의 연관이 대표적이다.

====== 1:N 연관

카테고리 입장에서 한 카테고리에 한 개 이상의 상품이 속할 수 있으니 카테고리와 상품은 1:N 관계이다.
한 상품이 한 카테고리에만 속할 수 있으니 상품과 카테고리 관계는 N:1 관계이다.

애그리거트 간 1:N 관계는 Set과 같은 컬렉션을 이용해서 표현할 수 있을 것이다.

[TIP]
====
|===
|===

Set 컬렉션,

순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.

|===
|===

List 컬렉션,

순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.

|===
|===

Map 컬렉션,

키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합이다.
순서는 유지되지 않고, 키는 중복을 허용하지 않으며 값의 중복을 허용한다.

|===
|===
====

다음의 코드처럼 Category가 연관된 Product를 값으로 갖는 컬렉션을 필드로 정의할 수 있다.

[source, java]
----
public class Category {

  private Set<Product> products;
}
----

* 개념적으로는 애그리거트 간에 1:N 연관이 있더라도 성능상의 문제 때문에 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 경우는 드물다.
** 보통 목록 관련 페이지에서는 페이징을 통해 목록을 나눠서 보여준다. 이 기능을 Category 입장에서 1-N 연관을 이용해서 코드를 실제 DBMS와 연동해서 구현하면 Category에 속한 모든 Product를 조회하게 된다.
Product 개수가 수백에서 수만개 정도로 많다면 이 코드를 실행할 때마다 실행 속도가 급격히 느려져 성능에 심각한 문제를 일으킬 것이다.

* Category에 속한 상품을 구할 필요가 있다면 상품 입장에서 자신이 속한 카테고리를 N:1로 연관지어 구하면 된다.

[source, java]
----
public class Product {
  ...
  private CategoryId category;
  ...
}
----

====== M:N 연관

M:N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.

상품이 여러 카테고리에 속할 수 있다고 가정하면 카테리와 상품은 M:N 연관을 맺는다.

보통 특정 카테고리에 속한 상품 목록을 보여줄 때 목록 화면에서 각 상품이 속한 모든 카테고리를 상품 정보에 표시하지 안흔ㄴ다.
제품이 속한 모든 카테고리가 필요한 화면은 상품 상세 화면이다.

이 요구사항을 고려할 때 카테고리에서 상품으로의 집합 연관은 필요하지 않다.1

즉, 개념적으로는 상품과 카테고리의 양방향 M:N 연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단방향 M:N 연관만 적용하면 되는 것이다.

[source, java]
----
public class Product {

  private Set<CategoryId> categoryId;
  ...

}
----

RDBMS를 이용해서 M:N 연관을 구현하려면 조인 테이블을 사용한다.
상품과 카테고리의 M:N 연관의 경우 [그림 3.9]와 같이 연관을 위한 조인 테이블을 이용해서 구현한다.

image::ch3_9.png[그림3.9, 600]
