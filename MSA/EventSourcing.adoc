= Event Sourcing

:icons: font
:Author: Byeongsoon Jang
:Email: byeongsoon94@gmail.com
:Date: 2020.09.08
:Revision: 1.0
:imagesdir: ./image



{Author}<{Email}>

---

==== Event Sourcing

Event Sourcing은 데이터를 저장하는 방법이다.

우리가 평소에 데이터를 저장하는 로직을 구현했을 땐 로직을 다 처리하고나서 결과값을 저장해왔다.

하지만 이벤트 소싱은 순차적으로 발생하는 이벤트를 모두 저장한다.

====
학습을 위해 책을 구매하기 위해서 교보문고 홈페이지를 이용한다고 가정하자.

책#1을 장바구니에 담고, 다른 책들도 살펴보다가 책#2도 장바구니에 담았다.

결재를 하려고 하다가 생각해보니 책#1은 이미 가지고 있는 것이라 구매할 필요가 없어서 장바구니에서 삭제한다.

이 상황을 기존의 방식으로 코딩하면 우린 책#2만 가지고 있을 것이다.

하지만 같은 상황에서 이벤트 소싱을 적용한 데이터 저장방법은 이벤트 자체를 저장하기 때문에

"사용자가 책#1을 장바구니에 추가한다.",

"책#2을 장바구니에 추가한다.",

"책#1을 장바구니에서 삭제한다"라는 이벤트 자체가 저장되는 방식이다.

따라서, 이벤트 소싱에서는 UPDATE, DELETE의 개념이 없다.
====

이벤트 소싱에서는 현재의 최종 값을 알기 위해서는 발생한 모든 이벤트를 재생하면서 현재 시점의 최종 값을 얻을 수 있다.

그런데 문제는 이벤트의 갯수가 너무 많아진다면 일일이 재생하여 최종 값을 얻는다면 시간이 너무 오래 걸릴 것이다.

이와 같은 문제를 해결하기 위한 것이 바로 스냅샷이다. 스냅샷을 찍을 값을 미리 정의해두고, 예를 들면 1000개 단위로 스냅샷을 찍고 우리가 1004개의 이벤트가 있다고하면 1000번째 스냅샷 이후 1001번째 이벤트부터 재생해서 최종 값을 얻을 수 있다.

==== 이벤트 소싱 장점 및 단점

* 장점
** 이벤트로 저장하기 때문에 관계형 모델로 매핑되지 않는다.
** 수정되거나 삭제되지 않고 추가만 되기 때문에 기존 데이터에 접근하기 위한 경쟁이 발생하지 않는다.
** 예시로 쇼핑몰에 이벤트 소싱을 사용했을 때, 기존 사용자들이 장바구니에 담았다가 가장 많이 삭제한 물품을 알아볼 수 있다.

* 단점
** 조회 작업에 적합하지 않다.
*** 조회가 힘들기 때문에 이벤트 소싱은 항상 CQRS(Command and Query Responsibility Segregation)와 함께 사용한다.
** 그 동안 모든 로직을 처리하고 결과값만을 저장하던 우리에게는 많이 낯설다.
** 기존 저장 방식에 비해서 도구가 부족하다.
