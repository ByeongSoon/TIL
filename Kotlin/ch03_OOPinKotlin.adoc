= 코틀린과 객체 지향 프로그래밍

:icons: font
:Author: Byeongsoon Jang
:Email: byeongsoon@wisoft.io
:Date: 2018.04.02
:Revision: 1.0

코틀린은 고차 함수와 람다식을 지원하는 객체 지향 프로그래밍 언어다.
코틀린은 현대적인 OOP 언어의 세 가지 기둥인 캡슐화, 상속, 다형성을 완벽하게 지원한다.
OOP 추상화는 대규모 코드에서 발생하는 문제를 완화하는 데 도움을 준다. OOP 추상화는 다음과 같은
기능을 제공함으로써 코드를 더욱 이해하거나 유지하기 쉽고 코드를 개선하기 쉽게 만들어줄 뿐만 아니라
코드를 버그로부터 자유롭게 만들어준다.

- 단순성: 프로그램 객체는 현실을 모델링하므로, 복잡성은 줄이고 프로그램 구조는 단순화한다.
- 모듈성: 각 객체의 내부 동작은 시스템의 다른 부분과 분리되어 있다.
- 가변성: 설계를 올바르게 했다면 객체 내부를 변경해도 프로그램의 다른 부분에 영향을 주지 않는다.
- 확장성: 객체의 요구사항은 빈번하게 바뀌며, 새로운 객체를 추가하거나 이미 존재하는 객체를 변경하는
방법으로 이러한 요구 사항에 빠르게 대응할 수 있다.
- 재활용성: 객체는 다른 프로그램에서 사용될 수 있다.

==== 목차

- 클래스와 인터페이스를 정의하고 사용하는 방법
- 어떤 상황에서 추상화 클래스보다 인터페이스를 선택해야 하는가
- 어떤 상황에서 합성보다 상속을 선택해야 하는가

|===
|===

==== 클래스

클래스는 각기 다른 타입의 변수와 메소드를 다 같이 그룹화하는 방법으로 사용자만의 타입을 만들 수 있게
해준다. 클래스는 다음 예제에서처럼 class 키워드를 사용해 선언한다.

[source, java]
----
class MyProject {
}
----

코틀린에서 클래스의 인스턴스를 생성하기 위해서는 생성자를 호출해야만한다. 위의 MyProject 클래스는 컴파일러에서
자동으로 만들어준 빈 생성자를 갖고있다.
그러나 직접 생성자를 제공하고 싶다면 다음과 같이 작성해야한다.

[source, java]
----
class Person constructor(val firstName: String, val lastName: String, val age: Int?) {}

fun main(args: Array<String>) {
  val person1 = Person("Alex", "Smith", 29)
  val person2 = Person("Jang", "Smith", null)
  println("${person1.firstName},${person1.lastName} is ${person1.age} years old.")
  println("${person2.firstName},${person2.lastName} is ${person2.age.toString
  ()?: "?"} years old.")
}
----

기존에 자바를 공부했다면 new 키워드가 빠져 있다는 사실을 확인했을 것이다. 자바에서 주어진 클래스의 새로운
인스턴스를 생성하기 위해서는 new MyClass처럼 항상 new 키워드를 사용해야 한다. 그러나 코틀린에서는
new 키워드를 사용할 필요가 없다.

constructor 키워드는 생성자를 가리키기 위한 표현이다. 코틀린에서는 접근 제어자나 애노테이션을 명시하지 않는
이상 사용하지 않아도 된다. 생성자의 입력 매개변수가 유효한지 체크는 init 블로에서 한다. require 메소드는
주어진 표현식이 false일 경우, 작성한 메시지와 함께 IllegalAragumentException을 발생시킨다.

[source, java]
----
class Person (val firstName: String, val lastName: String, val age: Int?) {
  init {
    require(firstName.trim().length > 0) { "Invalid firstName argument."}
    require(lastName.trim().length > 0) { "Invalid lastName argument."}
    if( age != null) {
      require(age >= 0 && age <= 150) { "Invalid age argument."}
    }
  }
}

fun main(args: Array<String>) {
  val person1 = Person("Alex", "Smith", 29)
  val person2 = Person("Jang", "Smith", null)
  println("${person1.firstName},${person1.lastName} is ${person1.age} years old.")
  println("${person2.firstName},${person2.lastName} is ${person2.age.toString
  ()?: "?"} years old.")
}
----

생성자 인자에 접두사로 val이나 var를 반드시 붙일 필요는 없다.

[source, java]
----
class Person(firstName: String, lastName: String, age: Int?){
  private name: String
  private age: Int?

  init{
    this.name = "$firstName, $lastName"
    this.age = age
  }

  fun getName(): String = this.name
  fun getAge(): Int? = this.age
}
----

- 중첩 클래스

자바를 사용하다 보면 다른 클래스 내부에 클래스를 생성하는 개념을 보는데, 이를 다른 말로 하면 중첩 클래스를
생성한다고 한다. 코틀린에서도 이와 같은 일을 할 수 있는데 다음 코드를 통해 볼 수 있다.

[source, java]
----
class OuterClassName {
  class NestedClassName {

  }
}
----
